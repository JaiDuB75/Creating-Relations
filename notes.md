# Creating Relationships

## Database Relationships

### One-to-One Relationships

A one-to-one relationship is a relationship where each row in a table is connected to a single record in another table, and vice versa. Either table can be the primary table.

### One-to-Many Relationships

A one-to-many relationship is a relationship where each record in a table can relate to zero, one, or many records in another table. The table on the "one" side of the relationship is the primary table, whereas the table on the "many" side is the related table.

To implement a one-to-many relationship, create a foreign key column on the "many" side of the relationship to the primary key column on the "one" side of the relationship. So you create a foreign key column in the orders table that references the primary key of the customers table.

### Many-to-Many Relationships

A many-to-many relationship is a relationship where multiple records in a table are related to multiple records in another table.

To create a many-to-many relationship, you need to create an intermediate table, called a join table. A join table contains two foreign key columns to store the relationships between the two tables.

Specifically, you need to create a join table to track the many-to-many relationships in the employees and projects tables. The join table will also track any columns that describe the relationship of the employee to the project.

### Entity Relationship Diagrams 

Database designers typically use a diagram called an Entity Relationship Diagram (ERD) when they are creating a new database. An ERD is a diagram that allows database designers to visualize the tables and the relationships between the tables in a database.

## Relating Tables through Keys

Set up a database using ElephantSQL

### One-to-One relationship between the employees and departments tables

Create the Employee table: 

```sql
DROP TABLE if exists employees;

CREATE TABLE employees
(
  employee_id INTEGER PRIMARY KEY generated by default AS identity,
  first_name VARCHAR(100) NOT NULL,
  last_name VARCHAR(100) NOT NULL,
  phone VARCHAR(100),
  title VARCHAR(100),
  salary NUMERIC,
  hire_date DATE
);
```

Create the Department table: 

You will need to add a foreign key column in the departments table that references the employees table.

Syntax for creating a foreign key: 

```sql
<column name> <data type> REFERENCES <foreign table name>(<foreign column>)
```

Creating the department table: 

```sql
DROP TABLE if exists departments;

CREATE TABLE departments
(
  department_id INTEGER PRIMARY KEY generated by default AS identity,
  department_name VARCHAR(100) NOT NULL,
  manager INTEGER REFERENCES employees(employee_id) unique -- Foreign key
);
```

The manager column stores the foreign keys from the employees table. Setting it to unique ensures that each department is linked to only one manager, thereby enforcing a one-to-one relationship.

### One-to-Many relationship between the customers and orders tables

Recall that a customer can have multiple orders, and the orders can only belong to a single customer. Here, you will create a one-to-many relationship between the customer (the "one" side of the relationship) and the order records (the "many" side of the relationship).

Create the customers table

```sql
DROP TABLE if exists customers;

CREATE TABLE customers
(
  customer_id INTEGER PRIMARY KEY generated by default AS identity,
  first_name VARCHAR(100) NOT NULL,
  last_name VARCHAR(100) NOT NULL,
  phone VARCHAR(100),
  email VARCHAR(100),
  street VARCHAR(255),
  city VARCHAR(100),
  zip_code VARCHAR(5)
);
```

Create the orders table: 

To create a one-to-many relationship between the customers and orders tables, you would have to create a foreign key reference in the orders table to the customers table.

```sql
DROP TABLE if exists orders;

CREATE TABLE orders
(
  order_id INTEGER PRIMARY KEY generated by default AS identity,
	order_status INTEGER NOT NULL,
  order_date DATE NOT NULL,
	shipped_date DATE,
  customer_id INTEGER REFERENCES customers(customer_id) NOT NULL -- Foreign key
);
```

In the query above, you call the foreign key column customer_id and have it reference the primary key column of the customers table (which is customer_id).

### Many-to-Many relationships between the employees and projects tables

 Employees can work on multiple projects at the same time, and each project may involve several employees. Here, you will create many-to-many relationships between the employee and project records.

Create the projects table

```sql
DROP TABLE if exists projects;

CREATE TABLE projects
(
  project_id INTEGER PRIMARY KEY generated by default AS identity,
  project_name VARCHAR(255) NOT NULL,
  budget NUMERIC DEFAULT 0,
  start_date DATE,
  end_date DATE
);
```

Create the employees_projects join table
- create a join table to store the relationships between the employee and project records.

```sql
DROP TABLE if exists employees_projects;

CREATE TABLE employees_projects
(
  employee_id INTEGER REFERENCES employees(employee_id),
  project_id INTEGER REFERENCES projects(project_id),
  start_date DATE,
  end_date DATE,
  PRIMARY KEY (employee_id, project_id) -- Composite key
);
```

Each row in the employees_projects table links an employee to a project through two foreign key columns that reference primary keys from the employees and projects tables.

Additionally, combining the employee_id and project_id columns makes it possible to create a composite key. A composite key is a primary key created from combining multiple columns to guarantee the uniqueness of a record. Composite keys are useful when records in your dataset cannot be uniquely identified by a single column value but a combination of column values can.


### Testing the Database

Truncate a table

Before you add any data to your database, you should remove any existing data to ensure that the database remains in a consistent state. You can use the TRUNCATE command to do this. 

Example of truncating multiple tables: 

```sql
TRUNCATE
  tableA,
  tableB,
  tableC
RESTART IDENTITY;
```

The RESTART IDENTITY clause is helpful if you have primary key fields in the tables that you want to restart at 1 when you start adding new records to the tables again.

### Seed ing the Database: 

```sql
TRUNCATE
  employees,
  departments,
  projects,
  employees_projects,
  customers,
  orders
RESTART IDENTITY;

-- Insert some data into the employees table
INSERT INTO employees
  (first_name, last_name, phone, title, salary, hire_date)
  VALUES
    ('Jane', 'Doe','5551234', 'CEO', 80000, '12/07/1999'),
    ('Wright', 'Palmer', '5554321', 'Manager', 60000, '01/06/2001'),
    ('Jim', 'Doe', '5555678', 'Accountant', 50000, '11/06/2015'),
    ('Toby', 'Bestley', '5558765', 'Associate', 35000, '09/07/2008') ,
    ('Meredith', 'Hartford', '5559876', 'Associate', 30000, '02/17/2014'),
    ('Tom', 'Flenderson', '5558769', 'Associate', 32000, '11/23/2013'),
    ('Bently', 'Singh', '5554326', 'Manager', 60000, '06/06/2005'),
    ('Winnie', 'Lim', '5554527', 'Manager', 62000, '10/24/2003'),
    ('Ruda', 'Bross', '5554428', 'Manager', 66000, '11/06/2004');

-- Insert four projects into the projects table
INSERT INTO projects
  (project_name, budget, start_date)
  VALUES
    ('Build Database', 20000, '3/4/2020'),
    ('Plan christmas party', 500, '11/20/2020'),
    ('Remove old stock', 1000, '4/6/2020'),
    ('Watch paint dry', 3000, '2/11/2020');

-- Insert some customers into the customers table
INSERT INTO customers
  (first_name, last_name, phone, email, street, city, zip_code)
  VALUES
    ('Kacie', 'Mckee','5555234', 'kacie.mckee@gmail.com', '61 Shadow Brook Court', 'Melrose, MA', '02176'),
    ('Moses', 'Mcghee', '5554651', 'moses.mcghee@gmail.com', '570 Old York St.', 'Upland, CA', '91784'),
    ('Jerome', 'Aguilar', '5555699', 'jerome.aguilar@yahoo.com', '68 Victoria Road', 'Hoboken, NJ', '07030'),
    ('Ainsley', 'Bonner', '5558564', 'ainsley.bonner@hotmail.com', '60 Winchester Road', 'Dundalk, MD', '21222') ,
    ('Delilah', 'Bateman', '5523124', 'delilah.bateman@gmail.com', '482 E. Oxford St.', 'Thibodaux, LA', '70301');
```

### Testing the one-to-one relationship between the employees ad departments table

```sql
INSERT INTO departments
  (department_name, manager)
  VALUES
    ('Administration', 2),
    ('Merchandising', 7),
    ('Customer Service', 8),
    ('Marketing', 9);
```

### Testing the one-to-many relationships between the customers and the orders tables 

```sql
INSERT INTO orders
  (order_status, order_date, shipped_date, customer_id)
  VALUES
    (1, '3/4/2020', NULL, 1),
    (2, '3/14/2020', NULL, 2),
    (4, '4/2/2020', '4/5/2020', 1),
    (4, '4/5/2020', '4/14/2020', 3),
    (3, '4/5/2020', NULL, 3),
    (4, '4/17/2020', '4/20/2020', 4),
    (3, '5/1/2020', NULL, 1),
    (4, '5/2/2020', '5/14/2020', 5),
    (3, '5/15/2020', NULL, 2);
```

Next, execute `SELECT * FROM orders;`

### Testing the many-to-many relationship between the employees abd projects tables 

```sql
-- Assign employees to projects
INSERT INTO employees_projects
  (employee_id, project_id, start_date, end_date)
  VALUES
    (7, 1, '3/4/2020', '6/1/2020'),
    (6, 2, '11/20/2020', '12/25/2020'),
    (7, 3, '4/6/2020', '4/12/2020'),
    (4, 4, '2/11/2020', '2/15/2020'),
    (7, 4, '2/25/2020', '3/15/2020'),
    (2, 4, '2/11/2020', '2/25/2020'),
    (1, 4, '2/15/2020', '4/12/2020');
```

Next, execute `SELECT * FROM employees_projects;`

### Checking the ERD in DBeaver

Now that you have created a few tables with relationships, you can use DBeaver to generate an ERD for you. Under the public folder, right-click Tables and select View Diagram from the context menu. Use DBeaver to examine the tables that have been created.

## Joining Tables

### `JOIN` Queries

To query data from multiple tables, you need to join the tables. Tables that are related by a foreign key can be joined using the basic syntax below:

```sql
SELECT <columns>
FROM <table1>
  JOIN <table2>
  ON <related columns>;
```

To say the above in plain English—this query is first asking for data from a column (or columns) from table1 (SELECT...FROM). It then asks for data from a different table (table2) to be connected to these columns from the first table. The ON clause states that the data from table2 should only be pulled in where it has a relationship to the data from table1.

Example of joing tables: 

```sql
SELECT *
FROM departments
  JOIN employees
  ON departments.manager = employees.employee_id;
```

In this query, you specify that you want all rows of data where the manager ID in the departments table matches the employee_id in the employees table. Because you specified `SELECT *`, all columns from both tables will be returned.

Instead of returning all columns from both tables, it is best practice to explicitly list the column names in a SELECT statement and return only those columns from the query.

Suppose you are conducting an annual salary review for your departmental managers, and you only need data from the following columns:

- department_id and department_name from the departments table
- first_name, last_name, and salary from the employees table

```sql
-- It is also recommended to qualify all column names with the table name;
-- that is, `employees.salary` rather than just `salary`.
SELECT
  departments.department_id,
  departments.department_name,
  employees.first_name,
  employees.last_name,
  employees.salary
FROM
  departments
  JOIN employees
  ON departments.manager = employees.employee_id;
```

Creating table aliases: 

Notice the previous query was quite verbose. You can make use of table aliases to help reduce the number of keystrokes needed to type such queries. The table alias only exists within the query itself. To create an alias, simply specify the new alias in the FROM clause.

```sql
SELECT
  d.department_id,
  d.department_name,
  e.first_name,
  e.last_name,
  e.salary
FROM
  departments d -- Create alias `d` for the departments table
  JOIN employees e -- Create alias `e` for the employees table
  ON d.manager = e.employee_id;
```

### `INNER JOIN` Queries

The default type of `JOIN` query is the `INNER JOIN`. This query returns all rows where the two columns in the join condition match.


Suppose you would like to write an email to give each of your customers an update on their orders. To write the email, you need their order statuses, order dates, first names, and email addresses.

To get this information, you need to join the customers table to the orders table using the query below:

```sql
SELECT
  c.first_name as customer_name, -- Alias `first_name` as `customer_name`
  c.email,
  o.order_status,
  o.order_date
FROM
  customers c
  INNER JOIN
  orders o
  ON c.customer_id = o.customer_id;
```

Suppose you would like to call your customers whose orders were rejected (the orders with order_status of 3) to try to encourage them to submit a new order. To write this email, you will need your customers' order dates, their first and last names, and their phone numbers.

Again, to get this information, you need to join the customers table to the orders table, while using the WHERE clause to filter the rows to those whose order_status is 3.

```sql
SELECT
  c.first_name,
  c.last_name,
  c.phone,
  o.order_date
FROM
  customers c
  INNER JOIN
  orders o
  ON c.customer_id = o.customer_id
WHERE
  o.order_status = 3;
```

Only customers with rejected orders are returned from the query. Notice that the order_status column isn't displayed. This is because even though it was used in the WHERE clause, it wasn't included in the SELECT clause, and therefore it isn't returned in the query.

The employees' first and last names are stored in the employees table, while the project name is stored in the projects table. However, these two tables aren't directly related via a foreign key. They are related by a third table, employees_projects. That means we have to join three tables!

Here is the query for joining all three tables:

```sql
SELECT
  e.first_name,
  e.last_name,
  p.project_name as project -- Alias the column name as `project` for brevity
FROM
  employees e
  INNER JOIN
  employees_projects ep
  ON e.employee_id = ep.employee_id
  INNER JOIN
  projects p
  ON p.project_id = ep.project_id;
```

## Other Joins

### `LEFT JOIN`

Suppose that you need a list of all departments and their corresponding manager names. Suppose also that there is a new requirement this time around: if a department doesn't have a manager, then return the record for that department anyway but put a NULL value in the corresponding manager column.

Use the following Syntax: 

```sql
SELECT
  d.department_id AS id,
  d.department_name AS department,
  e.first_name AS manager_first_name,
  e.last_name AS manager_last_name
FROM
  departments d
  LEFT JOIN -- Specify `LEFT JOIN` here
  employees e
  ON d.manager = e.employee_id;
```

Consider the query above diagrammatically. Because the departments table is listed first in the FROM clause, it is considered to be on the left of the join, whereas the employees table is on the right.

To include the departments with no managers, you would need to perform a LEFT JOIN. A LEFT JOIN brings back all rows on the left side of a join, even if it doesn't match any rows on the right. If no matches are found, the right-side columns are returned with NULL values.

### `RIGHT JOIN`

Suppose you are interested in viewing a list of all employee names and the name of the department that they manage. However, an `INNER JOIN` will return only employees who actually manage departments.

In this case, you can use a `RIGHT JOIN`. A `RIGHT JOIN` will include all rows on the right of a join, regardless of whether it matches a row on the left or not. In cases where it does not match, left columns are returned with NULL values.

Use the follwong Code: 

```sql
SELECT
  e.first_name AS manager_first_name,
  e.last_name AS manager_last_name,
  d.department_id AS id,
  d.department_name AS department
FROM
  departments d
  RIGHT JOIN -- Specify `RIGHT JOIN` as the clause
  employees e
  ON d.manager = e.employee_id;
```

### `FULL JOIN`

Suppose you are planning to promote an employee to become a manager, and to support your decision-making process, you need to view a list of all departments and all employees. You can leverage a `FULL JOIN` in this instance. A `FULL JOIN` collates the results of both `LEFT JOIN` and `RIGHT JOIN` operations. The `FULL JOIN` keyword returns all rows when there is a match in the left table (the departments table in this case) or right table (the employees table in this case) records.

Execute the script below to list all departments and all employees:

```sql
SELECT
  d.department_id AS id,
  d.department_name AS department,
  e.first_name,
  e.last_name
FROM
  departments d
  FULL JOIN -- Specify `FULL JOIN` here
  employees e
  on d.manager = e.employee_id;
```
